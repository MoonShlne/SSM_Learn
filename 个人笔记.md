# SSM笔记

## 事务

### 1.装配事务管理实现对象

```java
   @Bean
     public TransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
```

### 2.使用注解来声明事务

@Transactional

如果声明在类上则所有方法都生效

对某个方法进行个性化则再在方法上声明即可   



#### 事务的属性

##### 1.只读

在注解后面 `readOnly` 参数赋值  默认为false 

如果是true  则只能进行数据库查询操作，不能增删改操作，但是可以提高性能

> 使用场景主要为：对整个类声明了事务注解，修改只读可以对单纯的查询方法提高性能

##### 2.超时时间

修改`timeout`属性，超时自动执行回滚，并抛出异常`TransactionTimedOutException`

##### 3.事务异常

当事务抛出运行时异常时，默认回滚，但是IO异常则不会

可以单独设置回滚异常 或是 不回滚异常

`rollbackFor` 指定要回滚的异常，默认有`runtimeException` 可以添加`IoException` 防止漏网之鱼

`noRollbackFor` 指定不会滚的异常类

##### 4.隔离级别

修改`propagation` 来指定隔离级别，来解决脏读、不可重复读和幻读等问题

##### 5.事务传播行为

修改`propagation`属性设置传播属性

1. `Propagation.REQUIRED`：如果当前存在事务，则加入当前事务，否则创建一个新事务。
2. `Propagation.REQUIRES_NEW`：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。
3. `Propagation.NESTED`：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与`Propagation.REQUIRED`一样。
4. `Propagation.SUPPORTS`：如果当前存在事务，则加入该事务，否则以非事务方式执行。
5. `Propagation.NOT_SUPPORTED`：以非事务方式执行，如果当前存在事务，挂起该事务。
6. `Propagation.MANDATORY`：必须在一个已有的事务中执行，否则抛出异常。
7. `Propagation.NEVER`：必须在没有事务的情况下执行，否则抛出异常。







## MyBatis

1.创建pojo类

2.创建Mapper接口  （代替Dao接口）

> 接口方法不能重载，不然配置文件的唯一ID找不到对应方法

3.创建mapper.xml    编写CRUD代码  

4.创建MyBatis的配置文件， 包含数据库连接信息 以及指定 mapper.xml位置

5.运行以及测试





## SpringMvc

### 1. URL 参数传递

- 参数附在查询字符串：`?name=张三&age=18`

- 方法签名

  > 如果形参名跟URL参数名不想同，则在形参前加@RequestParam（value= ××   required = 是否为必填项目 true&false)

  ```java
  // 参数名与 URL 参数同名，可直接接收
  public String demo(String name, Integer age) { … }
  ```

- 若形参名与 URL 参数不一致，可用 `@RequestParam`

  ```java
  public String demo(
      @RequestParam(value = "username", required = true) String name
  ) { … }
  ```

### 2. 多值参数

- URL 示例：`?hbs=1&hbs=2&hbs=3`

  > 形参返回值用同名 集合接收 并且  形参前加@RequestParam 不然不生效

- 形参接收：

  ```java
  public String demo(
      @RequestParam("hbs") List<Integer> hbsList
  ) { … }
  ```

### 3.路径传参

- URL示例：`user/1`

- 在设置路径参数填写("/path/{key1}/{key2}")

- 在形参添加注解

  ```java
  @GetMapping("/user/{id}/{name}")
  @ResponseBody
  public String getUser(@PathVariable Long id, 
                        @PathVariable("name") String uname) {
      System.out.println("id = " + id + ", uname = " + uname);
      return "user_detail";
  }
  ```

  



### 3. 对象参数传递

- URL 示例：`?id=1&name=张三&age=18`

- 形参数对象：

  ```java
  public String demo(User user) { … }
  // User 中需有 id/name/age 等属性及 getter/setter
  ```

### 4. JSON 参数传递

- 请求体中发送 JSON

- 要求：

  - 有对应实体类（如 `User`）
  - 形参加 `@RequestBody`
  - 项目引入 Jackson 依赖
  - 配置类上添加 `@EnableWebMvc`  (该注解会顺带把`handlerMapping`以及`handlerAdapter` 加入IOC容器，不需要自己手动添加)

- 示例：

  ```java
  @PostMapping("/add")
  public String addUser(@RequestBody User user) { … }
  ```

### 5. 获取 Cookie

```java
public String demo(
    @CookieValue("SESSIONID") String sessionId
) { … }
```

### 6. 获取请求头

```java
public String demo(
    @RequestHeader("User-Agent") String userAgent
) { … }
```

### 7. 原生 API & 共享域

- 直接在方法签参中声明即可：

  ```java
  public String demo(
      HttpServletRequest  request,
      HttpServletResponse response,
      HttpSession         session,
      ServletContext      application
  ) { … }
  ```





#### 全局异常处理

创建处理实体类   添加@`controllerAdvice`注解 

对特定异常进行处理  添加@exception 注解指定异常类 

```java
 @ExceptionHandler(ArithmeticException.class)
    public Object handler(ArithmeticException arithmeticException) {
        return arithmeticException.getMessage();
    }

    @ExceptionHandler(Exception.class)
    public Object exception(Exception e) {
        return e.getMessage();
    }
```

#### 拦截器使用

创建拦截器实现`HandlerInterceptor` 接口 ，重写方法 

```java
public class Process01Interceptor implements HandlerInterceptor {

    // if( ! preHandler()){return;}
    // 在处理请求的目标 handler 方法前执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler);
        System.out.println("Process01Interceptor.preHandle");
         
        // 返回true：放行
        // 返回false：不放行
        return true;
    }
 
    // 在目标 handler 方法之后，handler报错不执行!
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler + ", modelAndView = " + modelAndView);
        System.out.println("Process01Interceptor.postHandle");
    }
 
    // 渲染视图之后执行(最后),一定执行!
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler + ", ex = " + ex);
        System.out.println("Process01Interceptor.afterCompletion");
    }
}
```

注册拦截器 使其生效

在配置类中实现`WebMvcConfigurer`接口重写方法

```java
@Configuration
@ComponentScan("com.myself")
@EnableWebMvc
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截所有的handle 
        registry.addInterceptor(new MyInterceptor()); 
        //如果要指定生效类，则使用所提供方法（以下只是举例，不是全部方法）
        registry.addInterceptor(new MyInterceptor()).addPathPatterns();
        registry.addInterceptor(new MyInterceptor()).excludePathPatterns();

    }
}
```



## SSM整合

### 1.配置config文件  

`WebMvcConfig` （`ControllerConfig`）

```java
@Controller
@EnableWebMvc
@ComponentScan({"com.myself.controller", "com.myself.exceptionhandle"})  //扫描controller层，全局异常处理类
public class WebMvcJavaConfig implements WebMvcConfigurer {
    //静态资源处理
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    //配置视图解析器，用于将控制器返回的逻辑视图名解析为具体的视图文件路径。
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views","jsp");
    }
	//配置拦截器，并注册	
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
//        registry.addInterceptor(拦截器.class);
    }
}
```



`ServiceConfig`

```java
@Configuration
@EnableAspectJAutoProxy  //开启aop支持
@EnableTransactionManagement  //开启事务管理实现
@ComponentScan("com.myself.service")
public class ServiceJavaConfig {
    //定义了一个 TransactionManager Bean，使用 DataSourceTransactionManager 来管理数据库事务，并将数据源 DataSource 注入到事务管理器中。
    @Bean
    public TransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }

}
```

`MapperConifg`

```java
@Configuration
public class MapperJavaConfig {

    //将sqlSessionFactory 加入容器
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true);
        configuration.setLogImpl(Slf4jImpl.class);
        configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL);
        sqlSessionFactoryBean.setConfiguration(configuration);
        sqlSessionFactoryBean.setTypeAliasesPackage("com.myself.pojo");

        PageInterceptor pageInterceptor = new PageInterceptor();
        Properties properties = new Properties();
        properties.setProperty("helperDialect", "mysql");
        pageInterceptor.setProperties(properties);
        sqlSessionFactoryBean.addPlugins(pageInterceptor);

        sqlSessionFactoryBean.addPlugins();
        return sqlSessionFactoryBean;
    }


    //将mapper代理对象加到容器
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();
        mapperScannerConfigurer.setBasePackage("com.myself.mapper");
        return mapperScannerConfigurer;

    }
}

```



`DataSource`

```java
//将datasource 分开配置。如果放在mapperConfig里面会导致ioc加载顺序问题引发的读不到properties文件内容
@Configuration
@PropertySource("classpath:jdbc.properties")
public class DataSourceJavaConfig {
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.user}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean  //连接池
    public DataSource dataSource() {

        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setUrl(url);
        druidDataSource.setDriverClassName(driver);
        druidDataSource.setUsername(username);
        druidDataSource.setPassword(password);

        return druidDataSource;
    }
}

```

### 2.配置init初始化文件

> 初始化两个容器在SSM整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！
>
> web容器在spring的源码中会自己继承root容器

```java
public class SpringIoCInit extends AbstractAnnotationConfigDispatcherServletInitializer {
	//指定root容器对应的配置类
	@Override 
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{DataSourceJavaConfig.class, MapperJavaConfig.class, ServiceJavaConfig.class};
    }
  	//指定web容器对应的配置类
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebMvcJavaConfig.class};
    }

	//指定dispatcherServlet处理路径，通常为 / 
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

}
```

### 3.依次配置controller层 ，service层，以及mapper层
