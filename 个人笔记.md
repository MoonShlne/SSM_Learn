# SSM笔记

## 事务

### 1.装配事务管理实现对象

```java
   @Bean
     public TransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
```

### 2.使用注解来声明事务

@Transactional

如果声明在类上则所有方法都生效

对某个方法进行个性化则再在方法上声明即可   



#### 事务的属性

##### 1.只读

在注解后面 `readOnly` 参数赋值  默认为false 

如果是true  则只能进行数据库查询操作，不能增删改操作，但是可以提高性能

> 使用场景主要为：对整个类声明了事务注解，修改只读可以对单纯的查询方法提高性能

##### 2.超时时间

修改`timeout`属性，超时自动执行回滚，并抛出异常`TransactionTimedOutException`

##### 3.事务异常

当事务抛出运行时异常时，默认回滚，但是IO异常则不会

可以单独设置回滚异常 或是 不回滚异常

`rollbackFor` 指定要回滚的异常，默认有`runtimeException` 可以添加`IoException` 防止漏网之鱼

`noRollbackFor` 指定不会滚的异常类

##### 4.隔离级别

修改`propagation` 来指定隔离级别，来解决脏读、不可重复读和幻读等问题

##### 5.事务传播行为

修改`propagation`属性设置传播属性

1. `Propagation.REQUIRED`：如果当前存在事务，则加入当前事务，否则创建一个新事务。
2. `Propagation.REQUIRES_NEW`：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。
3. `Propagation.NESTED`：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与`Propagation.REQUIRED`一样。
4. `Propagation.SUPPORTS`：如果当前存在事务，则加入该事务，否则以非事务方式执行。
5. `Propagation.NOT_SUPPORTED`：以非事务方式执行，如果当前存在事务，挂起该事务。
6. `Propagation.MANDATORY`：必须在一个已有的事务中执行，否则抛出异常。
7. `Propagation.NEVER`：必须在没有事务的情况下执行，否则抛出异常。







## MyBatis

1.创建pojo类

2.创建Mapper接口  （代替Dao接口）

> 接口方法不能重载，不然配置文件的唯一ID找不到对应方法

3.创建mapper.xml    编写CRUD代码  

4.创建MyBatis的配置文件， 包含数据库连接信息 以及指定 mapper.xml位置

5.运行以及测试





## SpringMvc

### 1. URL 参数传递

- 参数附在查询字符串：`?name=张三&age=18`

- 方法签名

  > 如果形参名跟URL参数名不想同，则在形参前加@RequestParam（value= ××   required = 是否为必填项目 true&false)

  ```java
  // 参数名与 URL 参数同名，可直接接收
  public String demo(String name, Integer age) { … }
  ```

- 若形参名与 URL 参数不一致，可用 `@RequestParam`

  ```java
  public String demo(
      @RequestParam(value = "username", required = true) String name
  ) { … }
  ```

### 2. 多值参数

- URL 示例：`?hbs=1&hbs=2&hbs=3`

  > 形参返回值用同名 集合接收 并且  形参前加@RequestParam 不然不生效

- 形参接收：

  ```java
  public String demo(
      @RequestParam("hbs") List<Integer> hbsList
  ) { … }
  ```

### 3.路径传参

- URL示例：`user/1`

- 在设置路径参数填写("/path/{key1}/{key2}")

- 在形参添加注解

  ```java
  @GetMapping("/user/{id}/{name}")
  @ResponseBody
  public String getUser(@PathVariable Long id, 
                        @PathVariable("name") String uname) {
      System.out.println("id = " + id + ", uname = " + uname);
      return "user_detail";
  }
  ```

  



### 3. 对象参数传递

- URL 示例：`?id=1&name=张三&age=18`

- 形参数对象：

  ```java
  public String demo(User user) { … }
  // User 中需有 id/name/age 等属性及 getter/setter
  ```

### 4. JSON 参数传递

- 请求体中发送 JSON

- 要求：

  - 有对应实体类（如 `User`）
  - 形参加 `@RequestBody`
  - 项目引入 Jackson 依赖
  - 配置类上添加 `@EnableWebMvc`  (该注解会顺带把`handlerMapping`以及`handlerAdapter` 加入IOC容器，不需要自己手动添加)

- 示例：

  ```java
  @PostMapping("/add")
  public String addUser(@RequestBody User user) { … }
  ```

### 5. 获取 Cookie

```java
public String demo(
    @CookieValue("SESSIONID") String sessionId
) { … }
```

### 6. 获取请求头

```java
public String demo(
    @RequestHeader("User-Agent") String userAgent
) { … }
```

### 7. 原生 API & 共享域

- 直接在方法签参中声明即可：

  ```java
  public String demo(
      HttpServletRequest  request,
      HttpServletResponse response,
      HttpSession         session,
      ServletContext      application
  ) { … }
  ```





#### 全局异常处理

创建处理实体类   添加@`controllerAdvice`注解 

对特定异常进行处理  添加@exception 注解指定异常类 

```java
 @ExceptionHandler(ArithmeticException.class)
    public Object handler(ArithmeticException arithmeticException) {
        return arithmeticException.getMessage();
    }

    @ExceptionHandler(Exception.class)
    public Object exception(Exception e) {
        return e.getMessage();
    }
```

#### 拦截器使用

创建拦截器实现`HandlerInterceptor` 接口 ，重写方法 

```java
public class Process01Interceptor implements HandlerInterceptor {

    // if( ! preHandler()){return;}
    // 在处理请求的目标 handler 方法前执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler);
        System.out.println("Process01Interceptor.preHandle");
         
        // 返回true：放行
        // 返回false：不放行
        return true;
    }
 
    // 在目标 handler 方法之后，handler报错不执行!
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler + ", modelAndView = " + modelAndView);
        System.out.println("Process01Interceptor.postHandle");
    }
 
    // 渲染视图之后执行(最后),一定执行!
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("request = " + request + ", response = " + response + ", handler = " + handler + ", ex = " + ex);
        System.out.println("Process01Interceptor.afterCompletion");
    }
}
```

注册拦截器 使其生效

在配置类中实现`WebMvcConfigurer`接口重写方法

```java
@Configuration
@ComponentScan("com.myself")
@EnableWebMvc
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截所有的handle 
        registry.addInterceptor(new MyInterceptor()); 
        //如果要指定生效类，则使用所提供方法（以下只是举例，不是全部方法）
        registry.addInterceptor(new MyInterceptor()).addPathPatterns();
        registry.addInterceptor(new MyInterceptor()).excludePathPatterns();

    }
}
```



